/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/

import { GoogleGenAI, Modality, Type } from "@google/genai";
import type { 
    StoryMasterplan, 
    Critique,
    Documentation,
    ReferenceAssets,
    ReferenceAsset,
    ProgressUpdate,
    FinalAssets,
    AIRecommendation,
} from '../components/story-builder/types';
import { fileToGenerativePart } from "../utils/fileUtils";
import { parseJsonMarkdown } from "../utils/parserUtils";
import { imageBlobCache } from "./imageBlobCache";
import geminiWebService from './geminiWebService';
import { logger } from '../utils/logger';
import { formatApiError } from '../utils/errorUtils';

let ai: GoogleGenAI;

const initializeApi = () => {
    if (!process.env.API_KEY) {
        logger.log('ERROR', 'geminiService', 'API_KEY environment variable not set!');
        throw new Error("API Key is missing. Please configure it in your environment.");
    }
    ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
};

initializeApi();

const makeApiRequestWithRetry = async <T>(requestFn: () => Promise<T>, retries = 2, delay = 1500): Promise<T> => {
    try {
        return await requestFn();
    } catch (error: any) {
        if (retries > 0) {
            logger.log('WARNING', 'geminiService', `API request failed. Retrying in ${delay}ms...`, { retriesLeft: retries, error: error.message });
            await new Promise(res => setTimeout(res, delay));
            return makeApiRequestWithRetry(requestFn, retries - 1, delay * 2);
        }
        logger.log('ERROR', 'geminiService', 'API request failed after multiple retries.', error);
        throw error;
    }
};

// ====================================================================================
// PHOTO EDITOR SERVICES
// ====================================================================================

export async function editImageWithMask(
    baseImage: File,
    maskImage: File,
    prompt: string,
    referenceImage?: File | null
): Promise<Blob> {
    const baseImagePart = await fileToGenerativePart(baseImage);
    const maskImagePart = await fileToGenerativePart(maskImage, "image/png");

    const contents: any[] = [ { text: prompt }, baseImagePart, maskImagePart ];
    if (referenceImage) {
        contents.push(await fileToGenerativePart(referenceImage));
    }

    const result = await makeApiRequestWithRetry(() => 
        ai.models.generateContent({
            model: 'gemini-2.5-flash-image-preview',
            contents: { parts: contents },
            config: { responseModalities: [Modality.IMAGE, Modality.TEXT] }
        })
    );
    
    const imagePart = result.candidates?.[0]?.content?.parts?.find(p => p.inlineData);
    if (!imagePart || !imagePart.inlineData) {
        throw new Error("No image was generated by the API.");
    }

    const base64Data = imagePart.inlineData.data;
    const mimeType = imagePart.inlineData.mimeType;
    return await (await fetch(`data:${mimeType};base64,${base64Data}`)).blob();
}

export async function enhanceCreativePrompt(prompt: string): Promise<string> {
    const systemInstruction = `You are a helpful AI assistant specializing in photorealistic image generation prompts...`;
    const result = await makeApiRequestWithRetry(() => 
        ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: `Enhance this prompt: "${prompt}"`,
            config: { systemInstruction }
        })
    );
    return result.text.trim();
}

export async function generatePhotoshootImages(
    subjectImage: File,
    scenePrompt: string,
    numImages: number,
    sceneImage?: File | null
): Promise<Blob[]> {
    // This function will use the Gemini Web fallback if available for unlimited generation
    if (geminiWebService.isInitialized()) {
        logger.log('INFO', 'geminiService', 'Using Gemini Web fallback for photoshoot generation.');
        const imagePromises = Array(numImages).fill(0).map(() => 
            makeApiRequestWithRetry(() => {
                const files = sceneImage ? [subjectImage, sceneImage] : [subjectImage];
                return geminiWebService.generateImage(scenePrompt, files);
            })
        );
        return Promise.all(imagePromises);
    }
    
    // Fallback to official API if not connected
    logger.log('WARNING', 'geminiService', 'Gemini Web not connected. Using official API for photoshoot generation (limited).');
    const imagePromises = Array(numImages).fill(0).map(() => generateImageWithFallback(scenePrompt, [subjectImage]));
    return Promise.all(imagePromises);
}

export async function getAIRecommendations(image: File, presets: any[], context: string): Promise<AIRecommendation[]> {
    const systemInstruction = "You are an expert photo editor AI...";
    const imagePart = await fileToGenerativePart(image);
    const prompt = `Context: "${context || 'General improvement'}". Presets: ${JSON.stringify(presets.map(p => p.name))}. Analyze and recommend.`;

    const result = await makeApiRequestWithRetry(() =>
        ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: { parts: [{text: prompt}, imagePart] },
            config: { systemInstruction, responseMimeType: 'application/json' }
        })
    );
    return parseJsonMarkdown(result.text);
}

export async function getAIFilterRecommendations(image: File, presets: any[], context: string): Promise<{ presetName: string, reason: string }[]> {
    const systemInstruction = "You are a creative director AI...";
    const imagePart = await fileToGenerativePart(image);
    const prompt = `Context: "${context || 'Apply a creative filter'}". Filters: ${JSON.stringify(presets.map(p => p.name))}. Analyze and recommend.`;

    const result = await makeApiRequestWithRetry(() =>
        ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: { parts: [{text: prompt}, imagePart] },
            config: { systemInstruction, responseMimeType: 'application/json' }
        })
    );
    return parseJsonMarkdown(result.text);
}

// ====================================================================================
// STORY BUILDER SERVICES
// ====================================================================================

export async function generateImageWithFallback(prompt: string, referenceFiles: File[] = []): Promise<Blob> {
    if (geminiWebService.isInitialized()) {
        try {
            logger.log('INFO', 'geminiService', `Generating image with Gemini Web fallback: "${prompt.substring(0, 50)}..."`);
            return await geminiWebService.generateImage(prompt, referenceFiles);
        } catch (error) {
            logger.log('ERROR', 'geminiService', 'Gemini Web fallback failed. The connection may have expired.', error);
            // This will throw a user-friendly error to the UI
            throw new Error(formatApiError(error));
        }
    }

    logger.log('WARNING', 'geminiService', `Using official API for image generation: "${prompt.substring(0, 50)}..."`);
    const result = await makeApiRequestWithRetry(() =>
        ai.models.generateImages({
            model: 'imagen-4.0-generate-001',
            prompt: prompt,
            config: { numberOfImages: 1, aspectRatio: '1:1' }
        })
    );
    const base64Data = result.generatedImages[0].image.imageBytes;
    return await (await fetch(`data:image/jpeg;base64,${base64Data}`)).blob();
}

export const generateStoryMasterplan = async (userInput: any): Promise<StoryMasterplan> => {
    const prompt = `Based on this user input, generate a complete Story Masterplan in JSON format: ${JSON.stringify(userInput)}`;
    const systemInstruction = `You are a master storyteller...`;
    const result = await makeApiRequestWithRetry(() =>
        ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: { systemInstruction, responseMimeType: 'application/json' }
        })
    );
    return parseJsonMarkdown(result.text);
};

export const critiqueStoryMasterplan = async (plan: StoryMasterplan): Promise<Critique> => {
    const prompt = `Critique this story masterplan...`;
    const systemInstruction = `You are a professional story editor...`;
    const result = await makeApiRequestWithRetry(() =>
        ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: `${prompt}\n\n${JSON.stringify(plan)}`,
            config: { systemInstruction, responseMimeType: 'application/json' }
        })
    );
    return parseJsonMarkdown(result.text);
};

export const applyCritiqueToMasterplan = async (plan: StoryMasterplan): Promise<StoryMasterplan> => {
    const prompt = `Rewrite and improve this Story Masterplan...`;
    const systemInstruction = `You are a script doctor AI...`;
    const result = await makeApiRequestWithRetry(() =>
        ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: JSON.stringify(plan),
            config: { systemInstruction, responseMimeType: 'application/json' }
        })
    );
    return parseJsonMarkdown(result.text);
};

export const generateProductionBible = async (plan: StoryMasterplan): Promise<Documentation> => {
    const prompt = `Generate a set of production documents...`;
    const systemInstruction = `You are a production assistant AI...`;
    const result = await makeApiRequestWithRetry(() =>
        ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: JSON.stringify(plan),
            config: { systemInstruction, responseMimeType: 'application/json' }
        })
    );
    return parseJsonMarkdown(result.text);
};

export const generateReferenceAssets = async (plan: StoryMasterplan, onProgress: (update: ProgressUpdate) => void): Promise<ReferenceAssets> => {
    const assetsToGenerate: Omit<ReferenceAsset, 'assetId'>[] = plan.characters.map(char => ({
        id: `character_${char.name.toLowerCase().replace(/\s+/g, '_')}`,
        type: 'character',
        name: char.name,
        description: char.description,
        visualPrompt: char.visual_description,
    }));

    const generatedAssets: ReferenceAssets = { characters: [], environments: [], elements: [] };
    for (let i = 0; i < assetsToGenerate.length; i++) {
        const asset = assetsToGenerate[i];
        onProgress({ stage: 'reference_assets', status: 'in_progress', message: `Generating ${asset.type}: ${asset.name}...`, progress: ((i + 1) / assetsToGenerate.length) * 100 });
        const blob = await generateImageWithFallback(asset.visualPrompt);
        const assetId = `${asset.id}_${Date.now()}`;
        imageBlobCache.set(assetId, blob);
        const completedAsset: ReferenceAsset = { ...asset, assetId };
        if (asset.type === 'character') generatedAssets.characters.push(completedAsset);
    }
    return generatedAssets;
};

export const generateVideoAssets = async (plan: StoryMasterplan, references: ReferenceAssets, onProgress: (update: ProgressUpdate) => void): Promise<FinalAssets> => {
    onProgress({ stage: 'videos', status: 'in_progress', message: 'Starting video generation...' });
    const firstScene = plan.story_structure.narrative_arc[0]?.scenes[0];
    if (!firstScene) throw new Error("No scenes found.");

    const prompt = firstScene.visual_elements_prompt || `A video clip of: ${firstScene.summary}`;
    onProgress({ stage: 'videos', status: 'in_progress', message: `Generating video for Scene ${firstScene.scene_number}...`, sceneId: `scene_${firstScene.scene_number}` });
    
    let operation = await makeApiRequestWithRetry(() =>
        ai.models.generateVideos({
            model: 'veo-2.0-generate-001',
            prompt: prompt,
            config: { numberOfVideos: 1 }
        })
    );
    while (!operation.done) {
        await new Promise(resolve => setTimeout(resolve, 10000));
        operation = await ai.operations.getVideosOperation({ operation });
    }
    
    const downloadLink = operation.response?.generatedVideos?.[0]?.video?.uri;
    if (!downloadLink || !process.env.API_KEY) throw new Error("Failed to get video download link.");
    
    const response = await fetch(`${downloadLink}&key=${process.env.API_KEY}`);
    const blob = await response.blob();
    const assetId = `video_scene_${firstScene.scene_number}_${Date.now()}`;
    imageBlobCache.set(assetId, blob);

    onProgress({ stage: 'videos', status: 'complete', message: `Video for Scene ${firstScene.scene_number} complete.` });

    return { videoAssets: [{ sceneId: `scene_${firstScene.scene_number}`, segment: 1, totalSegments: 1, assetId }] };
};

export const resetAllAPIs = () => logger.log('INFO', 'geminiService', 'Resetting all API statuses (simulated).');
export const resetSpecificAPI = (projectName: string) => logger.log('INFO', 'geminiService', `Resetting API for ${projectName} (simulated).`);
